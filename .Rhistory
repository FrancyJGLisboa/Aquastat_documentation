# make aquastatElement an character
tbl <- tbl %>% mutate(aquastatElement = paste0("Value_", aquastatElement))
if (is.null(start_year) & !is.null(end_year)) {
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & is.null(end_year)) {
start_year <- as.integer(start_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & !is.null(end_year)) {
start_year <- as.integer(start_year)
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (is.null(start_year) & is.null(end_year)){
tbl %>%
dplyr::group_by(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
df_exts <- data.table(df_exts)
return(df_exts)
}
grouping_key <- c("geographicAreaM49", "aquastatElement")
df_exp <- aqua_expand_ts(dfflagrecovery, start_year = NULL, end_year = 2018, grouping_key = grouping_key)
## IMPUTATION -------
# Time-series expansion
#' The aqua_expand_ts is a helper for expanding time-series at a user-defined level of granularity (grouping_key)
#' and so defining the number of NA to be filled by the imputation process.
#' @param data a dataset containing at least geographicAreaM49, aquastatElement, timePointYear, and Value
#' @param start_year a integer setting the year in which the expansion should start. If NULL the mininum year the series is used.
#' @param end_year a integer setting the year in which the expansion should stop. If NULL, the max year the series is used.
#' @grouping_key a vector of character strings indicating the granulatiry level defining the original time-series length
#' br()
#' The function outputsa data.table/data.frame object with increased number of rows.
#' The extension to which the data set passed as argument increases depends on the start and end year passed to the function.
#' If start_year argument is NULL, the mininum year the series is used.
#' If end_year argument is NULL, the max year the series is used.
#' If both start_year and end_year are NULL, min and max years of the series will set the expansion boundaries.
aqua_expand_ts <- function(data, start_year = NULL, end_year = NULL, grouping_key = NULL) {
# ensure features as integers
data$geographicAreaM49 <- as.integer(data$geographicAreaM49)
data$aquastatElement<- as.integer(data$aquastatElement)
data$timePointYears <- as.integer(data$timePointYears)
# converts data into a tibble
tbl <- tbl_df(data)
# make aquastatElement an character
tbl <- tbl %>% mutate(aquastatElement = paste0("Value_", aquastatElement))
if (is.null(start_year) & !is.null(end_year)) {
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & is.null(end_year)) {
start_year <- as.integer(start_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & !is.null(end_year)) {
start_year <- as.integer(start_year)
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (is.null(start_year) & is.null(end_year)){
tbl %>%
dplyr::group_by(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
df_exts <- data.table(df_exts)
return(df_exts)
}
grouping_key <- c("geographicAreaM49", "aquastatElement")
df_exp <- aqua_expand_ts(dfflagrecovery, start_year = NULL, end_year = 2018, grouping_key = grouping_key)
## IMPUTATION -------
# Time-series expansion
#' The aqua_expand_ts is a helper for expanding time-series at a user-defined level of granularity (grouping_key)
#' and so defining the number of NA to be filled by the imputation process.
#' @param data a dataset containing at least geographicAreaM49, aquastatElement, timePointYear, and Value
#' @param start_year a integer setting the year in which the expansion should start. If NULL the mininum year the series is used.
#' @param end_year a integer setting the year in which the expansion should stop. If NULL, the max year the series is used.
#' @grouping_key a vector of character strings indicating the granulatiry level defining the original time-series length
#' br()
#' The function outputsa data.table/data.frame object with increased number of rows.
#' The extension to which the data set passed as argument increases depends on the start and end year passed to the function.
#' If start_year argument is NULL, the mininum year the series is used.
#' If end_year argument is NULL, the max year the series is used.
#' If both start_year and end_year are NULL, min and max years of the series will set the expansion boundaries.
aqua_expand_ts <- function(data, start_year = NULL, end_year = NULL, grouping_key = NULL) {
# ensure features as integers
data$geographicAreaM49 <- as.integer(data$geographicAreaM49)
data$aquastatElement<- as.integer(data$aquastatElement)
data$timePointYears <- as.integer(data$timePointYears)
# converts data into a tibble
tbl <- tbl_df(data)
# make aquastatElement an character
tbl <- tbl %>% mutate(aquastatElement = paste0("Value_", aquastatElement))
if (is.null(start_year) & !is.null(end_year)) {
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & is.null(end_year)) {
start_year <- as.integer(start_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & !is.null(end_year)) {
start_year <- as.integer(start_year)
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (is.null(start_year) & is.null(end_year)){
tbl %>%
dplyr::group_by(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
df_exts <- data.table(df_exts)
return(df_exts)
}
grouping_key <- c("geographicAreaM49", "aquastatElement")
df_exp <- aqua_expand_ts(dfflagrecovery, start_year = NULL, end_year = 2018, grouping_key = grouping_key)
## IMPUTATION -------
# Time-series expansion
#' The aqua_expand_ts is a helper for expanding time-series at a user-defined level of granularity (grouping_key)
#' and so defining the number of NA to be filled by the imputation process.
#' @param data a dataset containing at least geographicAreaM49, aquastatElement, timePointYear, and Value
#' @param start_year a integer setting the year in which the expansion should start. If NULL the mininum year the series is used.
#' @param end_year a integer setting the year in which the expansion should stop. If NULL, the max year the series is used.
#' @grouping_key a vector of character strings indicating the granulatiry level defining the original time-series length
#' br()
#' The function outputsa data.table/data.frame object with increased number of rows.
#' The extension to which the data set passed as argument increases depends on the start and end year passed to the function.
#' If start_year argument is NULL, the mininum year the series is used.
#' If end_year argument is NULL, the max year the series is used.
#' If both start_year and end_year are NULL, min and max years of the series will set the expansion boundaries.
aqua_expand_ts <- function(data, start_year = NULL, end_year = NULL, grouping_key = NULL) {
# ensure features as integers
data$geographicAreaM49 <- as.integer(data$geographicAreaM49)
data$aquastatElement<- as.integer(data$aquastatElement)
data$timePointYears <- as.integer(data$timePointYears)
# converts data into a tibble
tbl <- tbl_df(data)
# make aquastatElement an character
tbl <- tbl %>% mutate(aquastatElement = paste0("Value_", aquastatElement))
if (is.null(start_year) & !is.null(end_year)) {
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & is.null(end_year)) {
start_year <- as.integer(start_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & !is.null(end_year)) {
start_year <- as.integer(start_year)
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (is.null(start_year) & is.null(end_year)){
tbl %>%
dplyr::group_by(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
df_exts <- data.table(df_exts)
return(df_exts)
}
grouping_key <- c("geographicAreaM49", "aquastatElement")
df_exp <- aqua_expand_ts(dfflagrecovery, start_year = NULL, end_year = 2018, grouping_key = grouping_key)
## IMPUTATION -------
# Time-series expansion
#' The aqua_expand_ts is a helper for expanding time-series at a user-defined level of granularity (grouping_key)
#' and so defining the number of NA to be filled by the imputation process.
#' @param data a dataset containing at least geographicAreaM49, aquastatElement, timePointYear, and Value
#' @param start_year a integer setting the year in which the expansion should start. If NULL the mininum year the series is used.
#' @param end_year a integer setting the year in which the expansion should stop. If NULL, the max year the series is used.
#' @grouping_key a vector of character strings indicating the granulatiry level defining the original time-series length
#' br()
#' The function outputsa data.table/data.frame object with increased number of rows.
#' The extension to which the data set passed as argument increases depends on the start and end year passed to the function.
#' If start_year argument is NULL, the mininum year the series is used.
#' If end_year argument is NULL, the max year the series is used.
#' If both start_year and end_year are NULL, min and max years of the series will set the expansion boundaries.
aqua_expand_ts <- function(data, start_year = NULL, end_year = NULL, grouping_key = NULL) {
# ensure features as integers
data$geographicAreaM49 <- as.integer(data$geographicAreaM49)
data$aquastatElement<- as.integer(data$aquastatElement)
data$timePointYears <- as.integer(data$timePointYears)
# converts data into a tibble
tbl <- tbl_df(data)
# make aquastatElement an character
tbl <- tbl %>% mutate(aquastatElement = paste0("Value_", aquastatElement))
if (is.null(start_year) & !is.null(end_year)) {
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & is.null(end_year)) {
start_year <- as.integer(start_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & !is.null(end_year)) {
start_year <- as.integer(start_year)
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (is.null(start_year) & is.null(end_year)){
tbl %>%
dplyr::group_by(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
df_exts <- data.table(df_exts)
return(df_exts)
}
grouping_key <- c("geographicAreaM49", "aquastatElement")
df_exp <- aqua_expand_ts(dfflagrecovery, start_year = NULL, end_year = 2018, grouping_key = grouping_key)
knitr::opts_chunk$set(echo = T,
results = "hide")
## IMPUTATION -------
# Time-series expansion
#' The aqua_expand_ts is a helper for expanding time-series at a user-defined level of granularity (grouping_key)
#' and so defining the number of NA to be filled by the imputation process.
#' @param data a dataset containing at least geographicAreaM49, aquastatElement, timePointYear, and Value
#' @param start_year a integer setting the year in which the expansion should start. If NULL the mininum year the series is used.
#' @param end_year a integer setting the year in which the expansion should stop. If NULL, the max year the series is used.
#' @grouping_key a vector of character strings indicating the granulatiry level defining the original time-series length
#' br()
#' The function outputsa data.table/data.frame object with increased number of rows.
#' The extension to which the data set passed as argument increases depends on the start and end year passed to the function.
#' If start_year argument is NULL, the mininum year the series is used.
#' If end_year argument is NULL, the max year the series is used.
#' If both start_year and end_year are NULL, min and max years of the series will set the expansion boundaries.
aqua_expand_ts <- function(data, start_year = NULL, end_year = NULL, grouping_key = NULL) {
# ensure features as integers
data$geographicAreaM49 <- as.integer(data$geographicAreaM49)
data$aquastatElement<- as.integer(data$aquastatElement)
data$timePointYears <- as.integer(data$timePointYears)
# converts data into a tibble
tbl <- tbl_df(data)
# make aquastatElement an character
tbl <- tbl %>% mutate(aquastatElement = paste0("Value_", aquastatElement))
if (is.null(start_year) & !is.null(end_year)) {
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & is.null(end_year)) {
start_year <- as.integer(start_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (!is.null(start_year) & !is.null(end_year)) {
start_year <- as.integer(start_year)
end_year <- as.integer(end_year)
tbl %>%
dplyr::group_by_(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(start_year, end_year)) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
if (is.null(start_year) & is.null(end_year)){
tbl %>%
dplyr::group_by(.dots = grouping_key) %>%
tidyr::complete(timePointYears = seq(min(timePointYears, na.rm = TRUE), max(timePointYears, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::arrange_(.dots = grouping_key) -> df_exts
}
df_exts <- data.table(df_exts)
return(df_exts)
}
grouping_key <- c("geographicAreaM49", "aquastatElement")
df_exp <- aqua_expand_ts(dfflagrecovery, start_year = NULL, end_year = 2018, grouping_key = grouping_key)
require(dplyr)
d = readr::read_csv("tables/flagobs.csv")
knitr::kable(x = d,
caption = paste("AQUASTAT to SWS flag conversion"),
booktabs = TRUE)
baseline <- readRDS("Z:/AquastatValidation/output/Baseline/baseline.rds")
baselien
baseline
unique(baseline[, flagObservationStatus, flagMethod])
unique(baseline[, .(flagObservationStatus, flagMethod)])
flagmeth <- unique(baseline[, .(flagObservationStatus, flagMethod)])
write.csv(flagmeth, '~/github/bookdown/tables/flagmeth.csv', row.names = FALSE)
require(dplyr)
d = readr::read_csv("tables/flagmeth.csv")
knitr::kable(x = d,
caption = paste("flagObservationStatus - flagMethod combination brought by the faoswsAquastatBaseline module"),
booktabs = TRUE)
require(dplyr)
d = readr::read_csv("tables/flagmeth.csv")
knitr::kable(x = d %>% dplyr::mutate(flagObservationStatus = ifelse(is.na(flagObservationStatus), 'blank', flagObservationStatus)),
caption = paste("flagObservationStatus - flagMethod combination brought by the faoswsAquastatBaseline module"),
booktabs = TRUE)
require(dplyr)
d = readr::read_csv("tables/base_add_indicators.csv")
knitr::kable(x = d,
caption = paste("The new indicators resulting from the faoswsAquastatBaseline module"),
booktabs = TRUE)
require(dplyr)
d = readr::read_csv("tables/map4551.csv")
knitr::kable(x = d,
caption = paste("Increase in time-series completeness and geographic expansion of SDGs"),
booktabs = TRUE)
require(dplyr)
d = readr::read_csv("tables/map4550.csv")
knitr::kable(x = d,
caption = paste("Increase in time-series completeness and geographic expansion of SDGs"),
booktabs = TRUE)
require(dplyr)
d = readr::read_csv("tables/map4551.csv")
knitr::kable(x = d,
caption = paste("Increase in time-series completeness and geographic expansion of SDGs"),
booktabs = TRUE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/map4551.csv")
knitr::kable(x = d,
caption = paste("Increase in time-series completeness and geographic expansion of SDGs"),
booktabs = TRUE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/map4551.csv")
knitr::kable(x = d[,.(geographicAreaM49, geographicAreaM49_description, count_bef, count_after)],
caption = paste("Increase in time-series completeness and geographic expansion of SDGs"),
booktabs = TRUE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/map4551.csv")
knitr::kable(x = d[,.(geographicAreaM49, geographicAreaM49_description, aquastatElement_description, count_bef, count_after)],
caption = paste("Increase in time-series completeness and geographic expansion of SDGs"),
booktabs = TRUE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/map4551.csv")
d <- d[,.(geographicAreaM49_description, count_bef, count_after)]
setnames(d, 'count_bef', 'before_module')
setnames(d, 'count_after','after_module')
knitr::kable(x = d,
caption = paste("Increase in time-series completeness and geographic expansion of SDG 6.4.1 (Water Use Efficiency"),
booktabs = TRUE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/map4550.csv")
d <- d[,.(geographicAreaM49_description, count_bef, count_after)]
setnames(d, 'count_bef', 'before_module')
setnames(d, 'count_after','after_module')
knitr::kable(x = d,
caption = paste("Increase in time-series completeness and geographic expansion of SDG 6.4.1 (Water Stress"),
booktabs = TRUE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/base_output.csv")
require(dplyr)
require(data.table)
d = data.table::fread("tables/base_output.rds")
require(dplyr)
require(data.table)
d = data.table::fread("tables/base_output.rds")
base_output <- readRDS("C:/Users/LISBOAF/Documents/github/bookdown/tables/base_output.rds")
d = readRDS("tables/base_output.rds")
d
di = readRDS("tables/base_input.rds")
di
di_af <-di[geographicAreaM49 = 4,.(geographicAreaM49_description, timePointYears, Value, flagObservationStatus, flagMethod)]
di_af <-di[geographicAreaM49 == 4,.(geographicAreaM49_description, timePointYears, Value, flagObservationStatus, flagMethod)]
knitr::include_graphics("images/outputbaselinesws.jpg")
print('Starting at: ')
options(scipen = 999)
##' AquastatBaseline module
##' Author: Francy Lisboa
##' Date: 20/02/2019
##' Purpose: this R script adds new figures to the aquastat dataset by applying
##' calculation - imputation - recalculation sequentialy.
##' The output will be the new baseline for future updates of the Aquastat in the SWS context
# Loading libraries
suppressMessages({
library(faosws)
library(faoswsUtil)
library(faoswsFlag)
library(data.table)
library(dplyr)
library(tidyr)
library(stringr)
library(magrittr)
library(zoo)
})
if(CheckDebug()){
library(faoswsModules)
SETTINGS = ReadSettings("~./github/faoswsAddIndicators/sws.yml")
Sys.setenv("R_SWS_SHARE_PATH" = SETTINGS[["share"]])
R_SWS_SHARE_PATH = SETTINGS[["share"]]
SetClientFiles(SETTINGS[["certdir"]])
GetTestEnvironment(baseUrl = SETTINGS[["server"]],
token = SETTINGS[["token"]])
}
di_af <-di[geographicAreaM49 == 4 & aquastatElement == '4157L',.(geographicAreaM49_description, timePointYears, Value, flagObservationStatus, flagMethod)]
do_af <-do[geographicAreaM49 == 4 & aquastatElement == '4157L']
do
do = readRDS("tables/base_output.rds")
do
do_af <-do[geographicAreaM49 == 4 & aquastatElement == '4157']
do_af
di_af <-di[geographicAreaM49 == 4 & aquastatElement == '4157']
di_af
setnames(di_af, 'Value', 'Value_original')
do_af <-do[geographicAreaM49 == 4 & aquastatElement == '4157']
setnames(di_af, 'Value', 'Value_corrected')
setnames(do_af, 'Value', 'Value_corrected')
do_af
do_af <- do_af[, .(geographicAreaM49, aquastatElement, timePointYears, Value_corrected)]
di_af <- di_af[, .(geographicAreaM49, aquastatElement, timePointYears, Value_corrected)]
di_af <- di_af[, .(geographicAreaM49, aquastatElement, timePointYears, Value_original)]
daf <- merge(di_af, do_af)
daf
daf <- nameData('aquastat', 'aquastat_dan', daf)
daf <- daf[, geographicAreaM49_description, aquastatElement_description, timePointYears, Value_original, Value_corrected ]
daf <- daf[, .(geographicAreaM49_description, aquastatElement_description, timePointYears, Value_original, Value_corrected) ]
daf
daf4157 <- daf[, .(geographicAreaM49_description, timePointYears, Value_original, Value_corrected) ]
write.csv(daf4157, '~/github/bookdown/tables/daf4157.csv', row.names = FALSE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/daf4157.csv")
knitr::kable(x = d,
caption = paste("LTA correction (Total internal renewable water resources (IRWR) [10^9 m3/year]) from the module"),
booktabs = TRUE)
require(dplyr)
require(data.table)
d = data.table::fread("tables/daf4157.csv")
knitr::kable(x = d,
caption = paste("LTA correction in Afghanistan on the element 'Total internal renewable water resources (IRWR) [10^9 m3/year]'"),
booktabs = TRUE)
require(data.table)
# lta <- c(4150L, 4151L, 4154L, 4155L, 4156L, 4157L, 4159L, 4160L,
#          4161L, 4162L, 4164L, 4165L, 4168L, 4170L, 4171L, 4172L, 4173L,
#          4174L, 4176L, 4177L, 4178L, 4182L, 4185L, 4187L, 4188L, 4192L,
#          4193L, 4194L, 4195L, 4196L, 4452L, 4453L, 4509L, 4536L,
#          4549L)
d = data.table::fread("tables/aquastat_meta_FL_sources.csv")
knitr::kable(x = d,
caption = paste("The description of AQUASTAT data"),
booktabs = TRUE)
